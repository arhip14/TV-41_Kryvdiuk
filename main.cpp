/* ----------------------------------------------------------------<Header>-
 –ù–∞–∑–≤–∞: domino_solver.cpp
 –ó–∞–≥–æ–ª–æ–≤–æ–∫: –†–æ–∑–≤‚Äô—è–∑—É–≤–∞—á –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏ –∑ –¥–æ–º—ñ–Ω–æ
 –ì—Ä—É–ø–∞:                     –¢–í-41
 –°—Ç—É–¥–µ–Ω—Ç:                   –ö—Ä–∏–≤–¥—é–∫ –ê.–í.
 –î–∞—Ç–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è:            2025-05-12
 –û—Å—Ç–∞–Ω–Ω—î —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è:       2025-05-12
 –û–ø–∏—Å:  –ü—Ä–æ–≥—Ä–∞–º–∞ –≤–∏—Ä—ñ—à—É—î –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –∑ –¥–æ–º—ñ–Ω–æ –Ω–∞ 2D –ø–æ–ª—ñ –º–µ—Ç–æ–¥–æ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ
        –ø–µ—Ä–µ–±–æ—Ä—É (backtracking). –ü–æ–ª–µ —á–∞—Å—Ç–∫–æ–≤–æ –∑–∞–ø–æ–≤–Ω–µ–Ω–µ —á–∏—Å–ª–∞–º–∏ –≤—ñ–¥ 0 –¥–æ 6.
        –ú–µ—Ç–∞ ‚Äî –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ –≤—Å—ñ –∫–ª—ñ—Ç–∏–Ω–∫–∏ —Ç–∞–∫, —â–æ–± –∫–æ–∂–Ω–∞ –ø–∞—Ä–∞ —Å—É—Å—ñ–¥–Ω—ñ—Ö —á–∏—Å–µ–ª —É—Ç–≤–æ—Ä—é–≤–∞–ª–∞
        –¥–æ–º—ñ–Ω–æ. –ö–æ–∂–Ω–∞ –º–æ–∂–ª–∏–≤–∞ –ø–∞—Ä–∞ —á–∏—Å–µ–ª (–Ω–µ–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –ø–æ—Ä—è–¥–∫—É) –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è
        —Ä—ñ–≤–Ω–æ –æ–¥–∏–Ω —Ä–∞–∑.
 ------------------------------------------------------------------</Header>-*/

#include <iostream>
#include <vector>
#include <set>
#include <fstream>
#include <iomanip>
#include <map>

using namespace std;

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: my_minmax
 –û–ø–∏—Å: –ü–æ–≤–µ—Ä—Ç–∞—î –ø–∞—Ä—É —á–∏—Å–µ–ª —É –ø–æ—Ä—è–¥–∫—É –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è.
 ---------------------------------------------------------------------[>]-*/
pair<int, int> my_minmax(int a, int b) {
    if (a < b) return {a, b};  // –ü–æ–≤–µ—Ä—Ç–∞—î –ø–∞—Ä—É –∑ –º–µ–Ω—à–∏–º —á–∏—Å–ª–æ–º —Å–ø–æ—á–∞—Ç–∫—É
    return {b, a};  // –Ø–∫—â–æ b –º–µ–Ω—à–µ, –ø–æ–≤–µ—Ä—Ç–∞—î –ø–∞—Ä—É –∑ b –Ω–∞ –ø–µ—Ä—à–æ–º—É –º—ñ—Å—Ü—ñ
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: insert_pair
 –û–ø–∏—Å: –î–æ–¥–∞—î –ø–∞—Ä—É –¥–æ –º–Ω–æ–∂–∏–Ω–∏, —è–∫—â–æ —ó—ó —â–µ –Ω–µ–º–∞—î.
 ---------------------------------------------------------------------[>]-*/
void insert_pair(set<pair<int, int>>& s, pair<int, int> p) {
    if (s.find(p) == s.end()) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ —î –ø–∞—Ä–∞ –≤ –º–Ω–æ–∂–∏–Ω—ñ
        s.insert(p);  // –Ø–∫—â–æ –ø–∞—Ä–∏ –Ω–µ–º–∞—î, –¥–æ–¥–∞—î–º–æ —ó—ó
    }
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: is_valid
 –û–ø–∏—Å: –ü–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ –º–æ–∂–Ω–∞ –≤—Å—Ç–∞–≤–∏—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è –≤ –æ–±—Ä–∞–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É, –ø–µ—Ä–µ–≤—ñ—Ä—è—é—á–∏
 –Ω–∞ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç–∏ –∑ —É–∂–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–∏–º–∏ —Å—É—Å—ñ–¥–Ω—ñ–º–∏ –∫–ª—ñ—Ç–∏–Ω–∫–∞–º–∏.
 ---------------------------------------------------------------------[>]-*/
bool is_valid(const vector<vector<int>>& grid, int row, int col, int value) {
    if (value < 0 || value > 6) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –¥–æ–ø—É—Å—Ç–∏–º—ñ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è
        return false;
    }
    int rows = grid.size();
    int cols = (rows > 0) ? grid[0].size() : 0;
    int dr[] = {-1, 1, 0, 0};
    int dc[] = {0, 0, -1, 1};
    
    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ —Å—É—Å—ñ–¥—ñ–≤: —á–∏ –º–æ–∂–Ω–∞ –≤—Å—Ç–∞–≤–∏—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è —É –ø–æ—Ç–æ—á–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É
    for (int i = 0; i < 4; ++i) {
        int nr = row + dr[i];
        int nc = col + dc[i];

    }
    return true;  // –Ø–∫—â–æ –∂–æ–¥–Ω–∏—Ö –∫–æ–Ω—Ñ–ª—ñ–∫—Ç—ñ–≤ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ, –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ true
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: find_next_missing
 –û–ø–∏—Å: –ó–Ω–∞—Ö–æ–¥–∏—Ç—å –Ω–∞—Å—Ç—É–ø–Ω—É –Ω–µ–∑–∞–ø–æ–≤–Ω–µ–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É –∑ –Ω–∞–π–º–µ–Ω—à–æ—é –∫—ñ–ª—å–∫—ñ—Å—Ç—é –º–æ–∂–ª–∏–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å.
 ---------------------------------------------------------------------[>]-*/
pair<int, int> find_next_missing(const vector<vector<int>>& grid) {
    int best_row = -1, best_col = -1;
    int min_possible_values = 8;  // –ü–æ—á–∞—Ç–∫–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –Ω–∞–π–º–µ–Ω—à–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –º–æ–∂–ª–∏–≤–∏—Ö –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤

    for (int r = 0; r < grid.size(); ++r) {
        for (int c = 0; c < grid[r].size(); ++c) {
            if (grid[r][c] == -1) {  // –Ø–∫—â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –Ω–µ–∑–∞–ø–æ–≤–Ω–µ–Ω–∞
                set<int> possible_values;
                for (int v = 0; v <= 6; ++v) {
                    if (is_valid(grid, r, c, v)) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –≤—Å—Ç–∞–≤–∫–∏ –∑–Ω–∞—á–µ–Ω–Ω—è
                        possible_values.insert(v);
                    }
                }
                // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–ª—ñ—Ç–∏–Ω–∫—É –∑ –Ω–∞–π–º–µ–Ω—à–æ—é –∫—ñ–ª—å–∫—ñ—Å—Ç—é –º–æ–∂–ª–∏–≤–∏—Ö –∑–Ω–∞—á–µ–Ω—å
                if (possible_values.size() < min_possible_values) {
                    min_possible_values = possible_values.size();
                    best_row = r;
                    best_col = c;
                }
            }
        }
    }
    return {best_row, best_col};  // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∑ –Ω–∞–π–º–µ–Ω—à–æ—é –∫—ñ–ª—å–∫—ñ—Å—Ç—é –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: get_formed_dominoes
 –û–ø–∏—Å: –ü–æ–≤–µ—Ä—Ç–∞—î –º–Ω–æ–∂–∏–Ω—É –≤—Å—ñ—Ö —É—Ç–≤–æ—Ä–µ–Ω–∏—Ö –¥–æ–º—ñ–Ω–æ –Ω–∞ –ø–æ–ª—ñ.
 ---------------------------------------------------------------------[>]-*/
 void draw_domino_lines(const vector<vector<int>>& grid, int r1, int c1, int r2, int c2);
 
set<pair<int, int>> get_formed_dominoes(const vector<vector<int>>& grid) {
    set<pair<int, int>> formed;
    int rows = grid.size();
    int cols = (rows > 0) ? grid[0].size() : 0;

    // –ü—Ä–æ—Ö–æ–¥–∏–º–æ –ø–æ –∫–æ–∂–Ω—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ —ñ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ –¥–æ–º—ñ–Ω–æ
    for (int r = 0; r < rows; ++r) {
        for (int c = 0; c < cols; ++c) {
            if (grid[r][c] != -2) {  // –Ø–∫—â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –Ω–µ –ø—É—Å—Ç–∞
                if (c + 1 < cols && grid[r][c + 1] != -2) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–∞–≤–æ–≥–æ —Å—É—Å—ñ–¥–∞
                    pair<int, int> domino = my_minmax(grid[r][c], grid[r][c + 1]);
                    insert_pair(formed, domino);
                    draw_domino_lines(grid, r, c, r, c + 1);
                }
                if (r + 1 < rows && grid[r + 1][c] != -2) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∏–∂–Ω—å–æ–≥–æ —Å—É—Å—ñ–¥–∞
                    pair<int, int> domino = my_minmax(grid[r][c], grid[r + 1][c]);
                    insert_pair(formed, domino);
                    draw_domino_lines(grid, r, c, r + 1, c);
                }
            }
        }
    }
    return formed;  // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –º–Ω–æ–∂–∏–Ω—É —Å—Ñ–æ—Ä–º–æ–≤–∞–Ω–∏—Ö –¥–æ–º—ñ–Ω–æ
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: is_solution
 –û–ø–∏—Å: –ü–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ –≤—Å—ñ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ –¥–æ–º—ñ–Ω–æ –ø—Ä–∏—Å—É—Ç–Ω—ñ –Ω–∞ –ø–æ–ª—ñ.
 ---------------------------------------------------------------------[>]-*/
bool is_solution(const vector<vector<int>>& grid, const set<pair<int, int>>& all_dominoes) {
    set<pair<int, int>> formed_dominoes = get_formed_dominoes(grid);
    return formed_dominoes == all_dominoes;  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –≤—Å—ñ –¥–æ–º—ñ–Ω–æ —É—Ç–≤–æ—Ä–µ–Ω—ñ
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: can_lead_to_solution
 –û–ø–∏—Å: –ü–µ—Ä–µ–≤—ñ—Ä—è—î, —á–∏ –ø–æ—Ç–æ—á–Ω–µ –ø–æ–ª–µ —â–µ –º–æ–∂–µ –ø—Ä–∏–≤–µ—Å—Ç–∏ –¥–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–æ–∑–≤'—è–∑–∫—É.
 ---------------------------------------------------------------------[>]-*/
bool can_lead_to_solution(const vector<vector<int>>& grid, const set<pair<int, int>>& all_dominoes) {
    cout << "üîç –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ —Ä—ñ—à–µ–Ω–Ω—è –Ω–∞ –ø–æ—Ç–æ—á–Ω–æ–º—É –ø–æ–ª—ñ\n";
    int filled_count = 0;
    for (const auto& row : grid) {
        for (int val : row) {
            if (val != -1 && val != -2) {
                filled_count++;  // –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ –≤–∂–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–∏—Ö –∫–ª—ñ—Ç–∏–Ω–æ–∫
            }
        }
    }
    return filled_count <= all_dominoes.size() * 2;  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ —Ä–µ—à—Ç—É –∫–ª—ñ—Ç–∏–Ω–æ–∫
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: solve_puzzle
 –û–ø–∏—Å: –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤–∏—Ä—ñ—à—É—î –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –º–µ—Ç–æ–¥–æ–º –ø–µ—Ä–µ–±–æ—Ä—É.
 ---------------------------------------------------------------------[>]-*/
bool solve_puzzle(vector<vector<int>>& grid, const set<pair<int, int>>& all_dominoes, set<pair<int, int>>& used_dominoes) {
    bool changed = true;
    while (changed) {
        changed = false;
        for (int r = 0; r < grid.size(); ++r) {
            for (int c = 0; c < grid[r].size(); ++c) {
                if (grid[r][c] >= 0) {  // –Ø–∫—â–æ –∫–ª—ñ—Ç–∏–Ω–∫–∞ –≤–∂–µ –∑–∞–ø–æ–≤–Ω–µ–Ω–∞
                    int dr[] = {-1, 1, 0, 0};
                    int dc[] = {0, 0, -1, 1};
                    int missing_neighbor_r = -1, missing_neighbor_c = -1;
                    int neighbor_count = 0;

                    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å—É—Å—ñ–¥—ñ–≤ –¥–ª—è –º–æ–∂–ª–∏–≤–∏—Ö –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤ –∑–Ω–∞—á–µ–Ω—å
                    for (int i = 0; i < 4; ++i) {
                        int nr = r + dr[i];
                        int nc = c + dc[i];
                        if (nr >= 0 && nr < grid.size() && nc >= 0 && nc < grid[nr].size()) {
                            if (grid[nr][nc] == -1) {
                                missing_neighbor_r = nr;
                                missing_neighbor_c = nc;
                                neighbor_count++;
                            } else if (grid[nr][nc] >= 0) {
                                neighbor_count++;
                            }
                        }
                    }

                    // –Ø–∫—â–æ —î —Ç—ñ–ª—å–∫–∏ –æ–¥–∏–Ω –≤–∞—Ä—ñ–∞–Ω—Ç –¥–ª—è —Å—É—Å—ñ–¥–Ω—å–æ—ó –∫–ª—ñ—Ç–∏–Ω–∫–∏
                    if (neighbor_count < 2 && missing_neighbor_r != -1) {
                        set<int> possible_values;
                        for (int v = 0; v <= 6; ++v) {
                            vector<vector<int>> temp_grid = grid;
                            temp_grid[missing_neighbor_r][missing_neighbor_c] = v;
                            set<pair<int, int>> formed = get_formed_dominoes(temp_grid);
                            pair<int, int> domino = my_minmax(grid[r][c], v);
                            if (all_dominoes.count(domino) && used_dominoes.find(domino) == used_dominoes.end()) {
                                possible_values.insert(v);
                            }
                        }
                        if (possible_values.size() == 1) {
                            grid[missing_neighbor_r][missing_neighbor_c] = *possible_values.begin();
                            cout << "‚ûï –î–æ–¥–∞—î—Ç—å—Å—è –¥–æ–º—ñ–Ω–æ: {" << grid[r][c] << ", " << *possible_values.begin() << "}\n";
                            insert_pair(used_dominoes, my_minmax(grid[r][c], *possible_values.begin()));
                            pair<int, int> domino = my_minmax(grid[r][c], *possible_values.begin());
                            if (used_dominoes.find(domino) != used_dominoes.end()) {
                                cout << "‚úÖ –î–æ–º—ñ–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ: {" << domino.first << ", " << domino.second << "}\n";
                            }
                            changed = true;
                        }
                    }
                }
            }
        }
    }

    pair<int, int> next_missing = find_next_missing(grid);
    int row = next_missing.first;
    int col = next_missing.second;

    if (row == -1) {
        if (is_solution(grid, all_dominoes)) {
            cout << "‚úÖ –†—ñ—à–µ–Ω–Ω—è –∑–Ω–∞–π–¥–µ–Ω–æ!\n";
            // --- Domino usage check ---
            cout << "‚úÖ –ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏—Ö –¥–æ–º—ñ–Ω–æ: " << used_dominoes.size() << " (–æ—á—ñ–∫—É—î—Ç—å—Å—è: 28)\n";
            for (const auto& d : used_dominoes) {
                cout << "–î–æ–º—ñ–Ω–æ: {" << d.first << "," << d.second << "}\n";
            }
        }
        return is_solution(grid, all_dominoes);  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω–æ –≤—Å–µ –∫–æ—Ä–µ–∫—Ç–Ω–æ
    }

    if (!can_lead_to_solution(grid, all_dominoes)) {
        return false;  // –Ø–∫—â–æ –≤–∂–µ –Ω–µ–º–æ–∂–ª–∏–≤–æ –∑–Ω–∞–π—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è
    }
    for (int value = 0; value <= 6; ++value) {
        if (is_valid(grid, row, col, value)) {  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –≤–∞–ª—ñ–¥–Ω—ñ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è
            vector<vector<int>> temp_grid = grid;
            temp_grid[row][col] = value;
            set<pair<int, int>> formed = get_formed_dominoes(temp_grid);
            set<pair<int, int>> new_used_dominoes = used_dominoes;
            bool possible = true;
            int dr[] = {-1, 1, 0, 0};
            int dc[] = {0, 0, -1, 1};
            for (int i = 0; i < 4; ++i) {
                int nr = row + dr[i];
                int nc = col + dc[i];
                if (nr >= 0 && nr < grid.size() && nc >= 0 && nc < grid[nr].size() && temp_grid[nr][nc] >= 0) {
                    pair<int, int> domino = my_minmax(value, temp_grid[nr][nc]);
                    if (all_dominoes.count(domino) && used_dominoes.count(domino)) {
                        possible = false;
                        break;
                    } else if (all_dominoes.count(domino)) {
                        cout << "‚ûï –î–æ–¥–∞—î—Ç—å—Å—è –¥–æ–º—ñ–Ω–æ: {" << value << ", " << temp_grid[nr][nc] << "}\n";
                        insert_pair(new_used_dominoes, domino);
                        if (new_used_dominoes.find(domino) != new_used_dominoes.end()) {
                            cout << "‚úÖ –î–æ–º—ñ–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ: {" << domino.first << ", " << domino.second << "}\n";
                        }
                    }
                }
            }

            if (possible) {
                grid[row][col] = value;
                // –í–∏–≤—ñ–¥ –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫—Ä–æ–∫—É –ø—ñ–¥–±–æ—Ä—É –∑–Ω–∞—á–µ–Ω–Ω—è
                cout << "–°–ø—Ä–æ–±–∞ –≤—Å—Ç–∞–≤–∏—Ç–∏ " << value << " —É –∫–ª—ñ—Ç–∏–Ω–∫—É (" << row << ", " << col << ")\n";
                if (solve_puzzle(grid, all_dominoes, new_used_dominoes)) {
                    cout << "‚úÖ –í–¥–∞–ª–æ—Å—å –≤—Å—Ç–∞–≤–∏—Ç–∏ " << value << " —É (" << row << ", " << col << ")\n";
                    return true;
                }
                // –Ø–∫—â–æ –Ω–µ –≤–¥–∞–ª–æ—Å—è, –≤—ñ–¥–∫–∞—Ç
                cout << "‚Ü©Ô∏è –í—ñ–¥–∫–∞—Ç –≤—Å—Ç–∞–≤–∫–∏ " << value << " –∑ –∫–ª—ñ—Ç–∏–Ω–∫–∏ (" << row << ", " << col << ")\n";
                grid[row][col] = -1;
            }
        }
    }
    return false;
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: print_grid
 –û–ø–∏—Å: –í–∏–≤–æ–¥–∏—Ç—å –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø–æ–ª—è –≤ –∫–æ–Ω—Å–æ–ª—å –∞–±–æ —É —Ñ–∞–π–ª.
 ---------------------------------------------------------------------[>]-*/
 void print_grid(const vector<vector<int>>& grid, ostream& os) {
    os << "\n==================== –†—ñ—à–µ–Ω–Ω—è ====================\n";
    for (const auto& row : grid) {
        for (int val : row) {
            if (val != -2) {
                os << setw(3) << val;
            } else {
                os << "   ";
            }
        }
        os << endl;
    }
    os << "==================================================\n";
}

/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: printHeader
 –û–ø–∏—Å: –í–∏–≤–æ–¥–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø—Ä–æ–≥—Ä–∞–º–∏ —ñ –æ–ø–∏—Å –∑–∞–≤–¥–∞–Ω–Ω—è.
 ---------------------------------------------------------------------[>]-*/
void printHeader() {
    cout << "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n";
    cout << "‚ïë                         üî∑–ö—É—Ä—Å–æ–≤–∞ —Ä–æ–±–æ—Ç–∞                       ‚ïë\n";
    cout << "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n";
    cout << "‚ïë  –ó–∞–≤–¥–∞–Ω–Ω—è: –†–æ–∑—Ä–æ–±—ñ—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º –≤–∏—Ä—ñ—à–µ–Ω–Ω—è –∑–∞–¥–∞—á—ñ —Ç–∞ —Ä–µ–∞–ª—ñ–∑—É–π—Ç–µ   ‚ïë\n";
    cout << "‚ïë  –π–æ–≥–æ —É –≤–∏–≥–ª—è–¥—ñ –ø—Ä–æ–≥—Ä–∞–º–∏ –º–æ–≤–æ—é ANSI C++                        ‚ïë\n";
    cout << "‚ïë  –Ü–¥–µ—è –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏ –∑ –∫—ñ—Å—Ç—è–∫–∞–º–∏ –¥–æ–º—ñ–Ω–æ. –ù–∞ —ñ–≥—Ä–æ–≤–æ–º—É –ø–æ–ª—ñ –∑–∞–¥–∞–Ω–æ  ‚ïë\n";
    cout << "‚ïë  –Ω–∞–±—ñ—Ä –¥–æ–º—ñ–Ω–æ, –∫–æ–∂–Ω–µ –¥–æ–º—ñ–Ω–æ –∑—É—Å—Ç—Ä—ñ—á–∞—î—Ç—å—Å—è —Ä—ñ–≤–Ω–æ –æ–¥–∏–Ω —Ä–∞–∑.      ‚ïë\n";
    cout << "‚ïë  –ù–∞–º–∞–ª—é–π—Ç–µ –ª—ñ–Ω—ñ—ó, —â–æ–± –≤—ñ–¥–∑–Ω–∞—á–∏—Ç–∏ —Å—Ç–∞–Ω–æ–≤–∏—â–µ –∫–æ–∂–Ω–æ–≥–æ –¥–æ–º—ñ–Ω–æ.     ‚ïë\n";
    cout << "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n";
    cout << ">> –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å Enter, —â–æ–± –ø–æ—á–∞—Ç–∏ –ø–æ—à—É–∫ —Ä—ñ—à–µ–Ω—å...\n";
    cin.ignore();
    cout << "\n‚è≥ –í–∏–∫–æ–Ω—É—î—Ç—å—Å—è –æ–±—á–∏—Å–ª–µ–Ω–Ω—è...\n\n";
}

void draw_domino_lines(const vector<vector<int>>& grid, int r1, int c1, int r2, int c2) {
    // Draw a line between two connected cells (either horizontally or vertically)
    if (r1 == r2) {  // Horizontal domino
        cout << "–ù–∞–º–∞–ª—å–æ–≤–∞–Ω–æ –ª—ñ–Ω—ñ—é –º—ñ–∂ –∫–ª—ñ—Ç–∏–Ω–∫–∞–º–∏ (" << r1 << "," << c1 << ") —Ç–∞ (" << r2 << "," << c2 << ")\n";
    } else if (c1 == c2) {  // Vertical domino
        cout << "–ù–∞–º–∞–ª—å–æ–≤–∞–Ω–æ –ª—ñ–Ω—ñ—é –º—ñ–∂ –∫–ª—ñ—Ç–∏–Ω–∫–∞–º–∏ (" << r1 << "," << c1 << ") —Ç–∞ (" << r2 << "," << c2 << ")\n";
    }
}


/* ---------------------------------------------------------------------[<]-
 –§—É–Ω–∫—Ü—ñ—è: main
 –û–ø–∏—Å: –û—Å–Ω–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è: –º–µ–Ω—é –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, –≤–≤–µ–¥–µ–Ω–Ω—è —Ç–∞ –∑–∞–ø—É—Å–∫ —Ä–æ–∑–≤‚Äô—è–∑–∞–Ω–Ω—è.
 ---------------------------------------------------------------------[>]-*/
int main() {
    printHeader();
    ofstream output("output.txt");
    vector<vector<int>> initial_grid = {
        {3, 6, -2, -2, -2, 0, 1, 1, 3, 0, 1, 5, 5},
        {6, 2, -2, -1, -2, 0, 4, 5, -1, 6, 1, 6, 2},
        {0, 4, -2, 0, -2, 6, 5, 6, 1, -1, 3, -2, -2},
        {0, 2, 3, 5, 2, 2, 3, 3, -2, -2, -1, -2, -2},
        {6, 4, 2, 4, 4, 3, 5, 2, -2, -2, 5, 0, 1},
        {-2, -2, 1, -1, 4, -2, -2, -1, -2, -2, 1, 4, 2}
    };

    set<pair<int, int>> all_dominoes;
    for (int i = 0; i <= 6; ++i) {
        for (int j = i; j <= 6; ++j) {
            all_dominoes.insert({i, j});
        }
    }

    vector<vector<int>> grid;
    set<pair<int, int>> used_dominoes_main;

    int choice = 0;
    while (true) {
        cout << "\n==================== –ú–µ–Ω—é ====================\n";
        cout << "1 - –í–≤–µ—Å—Ç–∏ —Å–∞–º–æ—Å—Ç—ñ–π–Ω–æ\n";
        cout << "2 - –í–≤–µ–¥–µ–Ω—ñ –ø—Ä–æ–≥—Ä–∞–º–æ—é –∑–Ω–∞—á–µ–Ω–Ω—è\n";
        cout << "3 - –í–∏—Ö—ñ–¥\n";
        cout << "=============================================\n";
        cout << "–í–∏–±–µ—Ä—ñ—Ç—å (1, 2, –∞–±–æ 3): ";

        cin >> choice;

        cout << "\n";

        if (choice == 1) {
            grid.clear();
            int rows, cols;
            cout << "–í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ä—è–¥–∫—ñ–≤: ";
            cin >> rows;
            cout << "–í–≤–µ–¥—ñ—Ç—å –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å—Ç–æ–≤–ø—Ü—ñ–≤: ";
            cin >> cols;

            grid.resize(rows, vector<int>(cols, -1));
            cout << "–í–≤–µ–¥—ñ—Ç—å –∑–Ω–∞—á–µ–Ω–Ω—è –ø–æ–ª—è (–∑–Ω–∞—á–µ–Ω–Ω—è –≤—ñ–¥ 0 –¥–æ 6, -1 –¥–ª—è –≤—Ç—Ä–∞—á–µ–Ω–∏—Ö –∑–Ω–∞—á–µ–Ω—å):\n";
            cout << "-2 –¥–ª—è –ø—É—Å—Ç–∏—Ö –∫–ª—ñ—Ç–∏–Ω–æ–∫) \n";
            for (int r = 0; r < rows; ++r) {
                for (int c = 0; c < cols; ++c) {
                    cin >> grid[r][c];
                }
            }

            cout << "\n –ü–æ—á–∞—Ç–æ–∫ –≤–∏—Ä—ñ—à–µ–Ω–Ω—è...\n";
            if (solve_puzzle(grid, all_dominoes, used_dominoes_main)) {
                cout << "\nüéâ –†—ñ—à–µ–Ω–Ω—è –∑–Ω–∞–π–¥–µ–Ω–æ!\n";
                print_grid(grid, cout);
                print_grid(grid, output);
                cout << "\nüîç –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏—Ö –¥–æ–º—ñ–Ω–æ...\n";
                cout << "‚úÖ –ö—ñ–ª—å–∫—ñ—Å—Ç—å –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏—Ö –¥–æ–º—ñ–Ω–æ: " << used_dominoes_main.size() << " (–æ—á—ñ–∫—É—î—Ç—å—Å—è: 28)\n";
                for (const auto& d : used_dominoes_main) {
                    cout << "–î–æ–º—ñ–Ω–æ: {" << d.first << "," << d.second << "}\n";
                }
            } else {
                cout << "‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ä—ñ—à–µ–Ω–Ω—è.\n";
                output << "‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ä—ñ—à–µ–Ω–Ω—è.\n";
            }

        } else if (choice == 2) {
            vector<vector<int>> solved_grid = initial_grid;

            cout << "–ü–æ—á–∞—Ç–æ–∫ –≤–∏—Ä—ñ—à–µ–Ω–Ω—è...\n";
            if (solve_puzzle(solved_grid, all_dominoes, used_dominoes_main)) {
                cout << "\nüéâ –†—ñ—à–µ–Ω–Ω—è –∑–Ω–∞–π–¥–µ–Ω–æ!\n";
                print_grid(solved_grid, cout);
                print_grid(solved_grid, output);
                for (const auto& d : used_dominoes_main) {
                    cout << "–î–æ–º—ñ–Ω–æ: {" << d.first << "," << d.second << "}\n";
                }
            } else {
                cout << "‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ä—ñ—à–µ–Ω–Ω—è.\n";
                output << "‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ä—ñ—à–µ–Ω–Ω—è.\n";
            }

        } else if (choice == 3) {
            cout << "–í–∏—Ö—ñ–¥ –∑ –ø—Ä–æ–≥—Ä–∞–º–∏...\n";
            break;

        } else {
            cout << "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –≤–≤—ñ–¥.\n";
        }
    }
}